#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble

\usepackage{xcolor}
\usepackage{listings}


% Haskell syntax highlighting
\lstdefinestyle{haskell}{
    language=Haskell,
    basicstyle=\small\ttfamily,
    keywordstyle=,
    commentstyle=\color{green!50!black},
    stringstyle=,
    showstringspaces=false,
    breaklines=true,
    frame=single,
    rulecolor=,
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    tabsize=4,
    captionpos=b,
    literate={->}{$\rightarrow$}{2}
               {>=}{$\geq$}{2}
               {<=}{$\leq$}{2}
}

\title{Seguridad informática}
\author{Pablo Alonso}
\date{23 de Octubre 2025}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding default
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 0
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\fontcolor #808080
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard

\end_layout

\begin_layout Section*
Ejercicio 4
\end_layout

\begin_layout Standard
En el ámbito de la seguridad informática, las amenazas pueden originarse
 tanto desde fuera de una organización (ataques externos) como desde dentro
 de ella (ataques internos).
 Aunque ambos tipos de amenazas buscan comprometer la confidencialidad,
 integridad o disponibilidad de la información, pero presentan diferencias
 significativas en cuanto a su naturaleza, motivaciones y métodos de defensa:
\end_layout

\begin_layout Itemize
Seguridad interna: Busca proteger la información del acceso indebido de
 parte de empleados, técnicos o cualquier persona que forma parte de la
 organización y tiene acceso autorizado a los sistemas de información.
 Poseen credenciales legítimas o conocimiento interno de los sistemas por
 lo cual sus acciones pueden parece legítimas y un ataque de este tipo puede
 ser muy difícil de detectar.
 Algunos ataques típicos que comprometen la seguridad interna son: - Robo
 de información confidencial por parte de un empleado.
 - Uso indebido de accesos.
 - Eliminación accidental de datos.
\end_layout

\begin_layout Itemize
Seguridad externa: Busca proteger la información del acceso indebido de
 parte de hackers, ciberdelincuentes o del acceso no autorizado de usuarios.
 A diferencia de la seguridad interna, este tipo de usuarios no tiene acceso
 privilegiado a los sistemas de información por lo cual cualquier acceso
 por parte de estos sujetos se considera una vulnerabilidad del sistema.
 Algunos ejemplos de ataques que buscan comprometer la seguridad externa
 son: ataques de phishing, malware, DDoS, intrusiones por vulnerabilidades
 no parcheadas o cubiertas.
\end_layout

\begin_layout Standard
Las medidas de seguridad interna pueden ser: - Restricción de acceso mínimo:
 Cada usuario debe poder acceder solo a lo que exija su nivel de acceso.
 - Correcta capacitación y concientización para prevenir el mal uso.
 - Registros de auditoría (logs) y monitoreo de comportamiento anómalo.
 - Sistemas DLP (Data Loss Prevention) para prevenir fuga de información.
 - Separación de funciones críticas (nadie debe tener control total sin
 supervisión).
 - Políticas claras de seguridad y sanciones por mal uso.
\end_layout

\begin_layout Standard
Mientras que las medidas de seguridad externa pueden ser: - Uso de firewalls,
 antivirus, sistemas de detección y prevención de intrusos (IDS/IPS).
 - Segmentación de redes y control de acceso desde Internet.
 - Políticas de actualización y parcheo de sistemas.
 - Autenticación multifactor (MFA) para reducir accesos no autorizados.
 - Monitoreo del tráfico externo y filtrado de correos (antiphishing, antispam).
\end_layout

\begin_layout Standard
Evolución con el progreso tecnológico:
\end_layout

\begin_layout Standard
Sí, las diferencias han evolucionado notablemente con el tiempo: En los
 inicios de los sistemas de información, las amenazas externas eran el foco
 principal, ya que los sistemas eran más aislados y los ataques internos
 se reducían a errores humanos.
 Con la conectividad masiva (Internet, nube, IoT, trabajo remoto), los límites
 entre lo interno y lo externo se volvieron difusos.
 Hoy en día, las organizaciones adoptan modelos de "confianza cero" (Zero
 Trust): nadie, ni siquiera los usuarios internos, se considera confiable
 por defecto.
 Además, la automatización, inteligencia artificial y análisis de comportamiento
 permiten detectar tanto ataques externos como internos con mayor precisión.
\end_layout

\begin_layout Section*
Ejercicio 8
\end_layout

\begin_layout Enumerate
Suponer que se cuenta con un sistema que administra registros médicos de
 pacientes.
 Como parte de su especificación, el sistema asegura que 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

los registros deben ser consistentes y exactos
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

.
 Suponer tambien que este sistema posee una base de datos SQL que almacena
 los registros de los pacientes.
 Si un atacante logra llevar a cabo una inyección de código SQL que corrompa
 dichos registros, el sistema posee un problema de security (se viola la
 integridad) y además el sistema rompe con su especificación (los registros
 ya no son consistentes).
\end_layout

\begin_layout Enumerate
Problema de security que NO es de safety.
 Se cuenta con un sistema que almacena datos encriptados de tarjetas de
 crédito.
 Ante el robo de datos de tarjetas de crédito almacenados en este sistema,
 se tiene un problema de security ( la confidencialidad se ve comprometida
 por el robo de información) pero el sistema cumple con su especificación
 (mantiene los datos encriptados) .
\end_layout

\begin_layout Enumerate
Se cuenta con un sistema de control de trenes que administra la circulacion
 de los trenes sobre un sistema complejo de vias.
 Suponer que el sistema tiene un bug en su implementacion por lo cual el
 algoritmo de control permite colisiones.
 El sistema viola su especificación y posee un problema de safety pero no
 un problema de security.
\end_layout

\begin_layout Section*
Ejercicio 15
\end_layout

\begin_layout Subsection*
Part a) Basic Bell-LaPadula Function
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "style=haskell,caption={Basic access control function}"
inline false
status open

\begin_layout Plain Layout

module BellLaPadula where
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Basic data types
\end_layout

\begin_layout Plain Layout

data SecurityLevel = Unclassified | Confidential 
\end_layout

\begin_layout Plain Layout

                  | Secret | TopSecret 
\end_layout

\begin_layout Plain Layout

                  deriving (Eq, Ord, Show)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

data AccessType = Read | Write deriving (Eq, Show)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

type UserName = String
\end_layout

\begin_layout Plain Layout

type FileName = String
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

data User = User
\end_layout

\begin_layout Plain Layout

  { userName :: UserName
\end_layout

\begin_layout Plain Layout

  , userClearance :: SecurityLevel
\end_layout

\begin_layout Plain Layout

  } deriving (Show)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

data File = File
\end_layout

\begin_layout Plain Layout

  { fileName :: FileName
\end_layout

\begin_layout Plain Layout

  , fileClassification :: SecurityLevel
\end_layout

\begin_layout Plain Layout

  } deriving (Show)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Main access control function
\end_layout

\begin_layout Plain Layout

grant :: User -> File -> AccessType -> Bool
\end_layout

\begin_layout Plain Layout

grant user file access = case access of
\end_layout

\begin_layout Plain Layout

  Read -> userClearance user >= fileClassification file
\end_layout

\begin_layout Plain Layout

  Write -> userClearance user <= fileClassification file
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Part b) Extended Function with State Tracking
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "style=haskell,caption={Extended function with open files tracking}"
inline false
status open

\begin_layout Plain Layout

import qualified Data.Map as Map
\end_layout

\begin_layout Plain Layout

import Data.Map (Map)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- System state tracking open files
\end_layout

\begin_layout Plain Layout

type OpenFiles = Map (UserName, FileName) AccessType
\end_layout

\begin_layout Plain Layout

data SystemState = SystemState
\end_layout

\begin_layout Plain Layout

  { securityPolicy :: Map (UserName, FileName) Bool
\end_layout

\begin_layout Plain Layout

  , openFiles :: OpenFiles
\end_layout

\begin_layout Plain Layout

  } deriving (Show)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Extended access control function
\end_layout

\begin_layout Plain Layout

grant' :: User -> File -> AccessType -> SystemState -> (Bool, SystemState)
\end_layout

\begin_layout Plain Layout

grant' user file access state =
\end_layout

\begin_layout Plain Layout

  let canAccess = case access of
\end_layout

\begin_layout Plain Layout

        Read -> userClearance user >= fileClassification file
\end_layout

\begin_layout Plain Layout

        Write -> userClearance user <= fileClassification file
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      -- Check *-property (no incompatible open modes)
\end_layout

\begin_layout Plain Layout

      alreadyOpen = Map.lookup (userName user, fileName file) (openFiles
 state)
\end_layout

\begin_layout Plain Layout

      propertyStarViolation = case (alreadyOpen, access) of
\end_layout

\begin_layout Plain Layout

        (Just Read, Write) -> True
\end_layout

\begin_layout Plain Layout

        (Just Write, _) -> True
\end_layout

\begin_layout Plain Layout

        _ -> False
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      accessGranted = canAccess && not propertyStarViolation
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      -- Update state if access granted
\end_layout

\begin_layout Plain Layout

      newOpenFiles = if accessGranted
\end_layout

\begin_layout Plain Layout

                     then Map.insert (userName user, fileName file) 
\end_layout

\begin_layout Plain Layout

                                    access (openFiles state)
\end_layout

\begin_layout Plain Layout

                     else openFiles state
\end_layout

\begin_layout Plain Layout

  in
\end_layout

\begin_layout Plain Layout

  (accessGranted, state { openFiles = newOpenFiles })
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Function to close files
\end_layout

\begin_layout Plain Layout

closeFile :: User -> File -> SystemState -> SystemState
\end_layout

\begin_layout Plain Layout

closeFile user file state =
\end_layout

\begin_layout Plain Layout

  state { openFiles = Map.delete (userName user, fileName file) (openFiles
 state) }
\end_layout

\end_inset


\end_layout

\end_body
\end_document
