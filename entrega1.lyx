#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble

\usepackage{xcolor}
\usepackage{listings}


% Haskell syntax highlighting
\lstdefinestyle{haskell}{
    language=Haskell,
    basicstyle=\small\ttfamily,
    keywordstyle=,
    commentstyle=\color{green!50!black},
    stringstyle=,
    showstringspaces=false,
    breaklines=true,
    frame=single,
    rulecolor=,
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    tabsize=4,
    captionpos=b,
    literate={->}{$\rightarrow$}{2}
               {>=}{$\geq$}{2}
               {<=}{$\leq$}{2}
}


\lstdefinestyle{cppstyle}{
language=C++,
basicstyle=\ttfamily\small,
keywordstyle=\color{blue}\bfseries,
commentstyle=\color{green!50!black}\itshape,
stringstyle=\color{red},
numbers=left,
numberstyle=\tiny, % tamaño de los números de línea
stepnumber=1,
numbersep=8pt,
frame=single,
breaklines=true,
showstringspaces=false,
tabsize=2,
captionpos=b
}

\title{Seguridad informática}
\author{Pablo Alonso}
\date{23 de Octubre 2025}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding default
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 0
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\fontcolor #808080
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section*
Ejercicio 4
\end_layout

\begin_layout Standard
En el ámbito de la seguridad informática, las amenazas pueden originarse
 tanto desde fuera de una organización (ataques externos) como desde dentro
 de ella (ataques internos).
 Aunque ambos tipos de amenazas buscan comprometer la confidencialidad,
 integridad o disponibilidad de la información, pero presentan diferencias
 significativas en cuanto a su naturaleza, motivaciones y métodos de defensa:
\end_layout

\begin_layout Itemize
Seguridad interna: Busca proteger la información del acceso indebido de
 parte de empleados, técnicos o cualquier persona que forma parte de la
 organización y tiene acceso autorizado a los sistemas de información.
 Poseen credenciales legítimas o conocimiento interno de los sistemas por
 lo cual sus acciones pueden parece legítimas y un ataque de este tipo puede
 ser muy difícil de detectar.
 Algunos ataques típicos que comprometen la seguridad interna son: - Robo
 de información confidencial por parte de un empleado.
 - Uso indebido de accesos.
 - Eliminación accidental de datos.
\end_layout

\begin_layout Itemize
Seguridad externa: Busca proteger la información del acceso indebido de
 parte de hackers, ciberdelincuentes o del acceso no autorizado de usuarios.
 A diferencia de la seguridad interna, este tipo de usuarios no tiene acceso
 privilegiado a los sistemas de información por lo cual cualquier acceso
 por parte de estos sujetos se considera una vulnerabilidad del sistema.
 Algunos ejemplos de ataques que buscan comprometer la seguridad externa
 son: ataques de phishing, malware, DDoS, intrusiones por vulnerabilidades
 no parcheadas o cubiertas.
\end_layout

\begin_layout Standard
Las medidas de seguridad interna pueden ser: - Restricción de acceso mínimo:
 Cada usuario debe poder acceder solo a lo que exija su nivel de acceso.
 - Correcta capacitación y concientización para prevenir el mal uso.
 - Registros de auditoría (logs) y monitoreo de comportamiento anómalo.
 - Sistemas DLP (Data Loss Prevention) para prevenir fuga de información.
 - Separación de funciones críticas (nadie debe tener control total sin
 supervisión).
 - Políticas claras de seguridad y sanciones por mal uso.
\end_layout

\begin_layout Standard
Mientras que las medidas de seguridad externa pueden ser: - Uso de firewalls,
 antivirus, sistemas de detección y prevención de intrusos (IDS/IPS).
 - Segmentación de redes y control de acceso desde Internet.
 - Políticas de actualización y parcheo de sistemas.
 - Autenticación multifactor (MFA) para reducir accesos no autorizados.
 - Monitoreo del tráfico externo y filtrado de correos (antiphishing, antispam).
\end_layout

\begin_layout Standard
Evolución con el progreso tecnológico:
\end_layout

\begin_layout Standard
Sí, las diferencias han evolucionado notablemente con el tiempo: En los
 inicios de los sistemas de información, las amenazas externas eran el foco
 principal, ya que los sistemas eran más aislados y los ataques internos
 se reducían a errores humanos.
 Con la conectividad masiva (Internet, nube, IoT, trabajo remoto), los límites
 entre lo interno y lo externo se volvieron difusos.
 Hoy en día, las organizaciones adoptan modelos de "confianza cero" (Zero
 Trust): nadie, ni siquiera los usuarios internos, se considera confiable
 por defecto.
 Además, la automatización, inteligencia artificial y análisis de comportamiento
 permiten detectar tanto ataques externos como internos con mayor precisión.
\end_layout

\begin_layout Section*
Ejercicio 8
\end_layout

\begin_layout Enumerate
Suponer que se cuenta con un sistema que administra registros médicos de
 pacientes.
 Como parte de su especificación, el sistema asegura que 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

los registros deben ser consistentes y exactos
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

.
 Suponer tambien que este sistema posee una base de datos SQL que almacena
 los registros de los pacientes.
 Si un atacante logra llevar a cabo una inyección de código SQL que corrompa
 dichos registros, el sistema posee un problema de security (se viola la
 integridad) y además el sistema rompe con su especificación (los registros
 ya no son consistentes).
\end_layout

\begin_layout Enumerate
Problema de security que NO es de safety.
 Se cuenta con un sistema que almacena datos encriptados de tarjetas de
 crédito.
 Ante el robo de datos de tarjetas de crédito almacenados en este sistema,
 se tiene un problema de security ( la confidencialidad se ve comprometida
 por el robo de información) pero el sistema cumple con su especificación
 (mantiene los datos encriptados) .
\end_layout

\begin_layout Enumerate
Se cuenta con un sistema de control de trenes que administra la circulacion
 de los trenes sobre un sistema complejo de vias.
 Suponer que el sistema tiene un bug en su implementacion por lo cual el
 algoritmo de control permite colisiones.
 El sistema viola su especificación y posee un problema de safety pero no
 un problema de security.
\end_layout

\begin_layout Section*
Ejercicio 15
\end_layout

\begin_layout Subsection*
a) Control de acceso con Bell-LaPadula
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "style=haskell,caption={Basic access control function}"
inline false
status open

\begin_layout Plain Layout

module BellLaPadula where
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import qualified Data.Map as Map
\end_layout

\begin_layout Plain Layout

import Data.Map (Map)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Tipos básicos
\end_layout

\begin_layout Plain Layout

data SecurityLevel = Unclassified | Confidential
\end_layout

\begin_layout Plain Layout

                  | Secret | TopSecret
\end_layout

\begin_layout Plain Layout

                  deriving (Eq, Ord, Show)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

data AccessType = Read | Write deriving (Eq, Show)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

type UserName = String
\end_layout

\begin_layout Plain Layout

type FileName = String
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

data User = User
\end_layout

\begin_layout Plain Layout

  { userName :: UserName
\end_layout

\begin_layout Plain Layout

  , userClearance :: SecurityLevel
\end_layout

\begin_layout Plain Layout

  } deriving (Show)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

data File = File
\end_layout

\begin_layout Plain Layout

  { fileName :: FileName
\end_layout

\begin_layout Plain Layout

  , fileClassification :: SecurityLevel
\end_layout

\begin_layout Plain Layout

  } deriving (Show)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Control de acceso básico
\end_layout

\begin_layout Plain Layout

grant :: User -> File -> AccessType -> Bool
\end_layout

\begin_layout Plain Layout

grant user file access = case access of
\end_layout

\begin_layout Plain Layout

  Read -> userClearance user >= fileClassification file
\end_layout

\begin_layout Plain Layout

  Write -> userClearance user <= fileClassification file
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
b) Control de acceso extendido preservando propiedad *
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "style=haskell,caption={Extended function with open files tracking}"
inline false
status open

\begin_layout Plain Layout

----- Extensión: Asegurar propiedad *
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Estado del sistema
\end_layout

\begin_layout Plain Layout

type OpenFiles = Map (UserName, FileName) AccessType
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

data SystemState = SystemState
\end_layout

\begin_layout Plain Layout

  { files :: Map FileName File            -- Store all files in the system
\end_layout

\begin_layout Plain Layout

  , openFiles :: OpenFiles
\end_layout

\begin_layout Plain Layout

  } deriving (Show)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Archivos abiertos en modo lectura por un usuario
\end_layout

\begin_layout Plain Layout

openReadFiles :: User -> SystemState -> [File]
\end_layout

\begin_layout Plain Layout

openReadFiles user state =
\end_layout

\begin_layout Plain Layout

    mapMaybe (
\backslash
((uname,fname), mode) ->
\end_layout

\begin_layout Plain Layout

                if uname == userName user && mode == Read
\end_layout

\begin_layout Plain Layout

                then Map.lookup fname (files state)
\end_layout

\begin_layout Plain Layout

                else Nothing)
\end_layout

\begin_layout Plain Layout

             (Map.toList $ openFiles state)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Control de acceso con seguimiento del estado del sistema
\end_layout

\begin_layout Plain Layout

grant' :: User -> File -> AccessType -> SystemState -> (Bool, SystemState)
\end_layout

\begin_layout Plain Layout

grant' user file access state =
\end_layout

\begin_layout Plain Layout

  let canAccess = grant user file access
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      -- Maximo nivel de seguridad en archivos abiertos
\end_layout

\begin_layout Plain Layout

      maxReadLevel = case openReadFiles user state of
\end_layout

\begin_layout Plain Layout

                       [] -> fileClassification file
\end_layout

\begin_layout Plain Layout

                       fs -> maximum $ map fileClassification fs
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      propertyStarViolation = case access of
\end_layout

\begin_layout Plain Layout

        Write -> fileClassification file < maxReadLevel
\end_layout

\begin_layout Plain Layout

        _     -> False
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      accessGranted = canAccess && not propertyStarViolation
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      -- Actualizar el estado del sistema
\end_layout

\begin_layout Plain Layout

      newOpenFiles = if accessGranted
\end_layout

\begin_layout Plain Layout

                     then Map.insert (userName user, fileName file)
\end_layout

\begin_layout Plain Layout

                                    access (openFiles state)
\end_layout

\begin_layout Plain Layout

                     else openFiles state
\end_layout

\begin_layout Plain Layout

  in
\end_layout

\begin_layout Plain Layout

  (accessGranted, state { openFiles = newOpenFiles })
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Cerrar archivos
\end_layout

\begin_layout Plain Layout

closeFile :: User -> File -> SystemState -> SystemState
\end_layout

\begin_layout Plain Layout

closeFile user file state =
\end_layout

\begin_layout Plain Layout

  state { openFiles = Map.delete (userName user, fileName file) (openFiles
 state) }
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Ejercicio 22
\end_layout

\begin_layout Subsection*
Programa 1
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "style=cppstyle,caption={Ejemplo: main.cpp}"
inline false
status open

\begin_layout Plain Layout

magic = readL();
\end_layout

\begin_layout Plain Layout

if (magic == 0xdeadbeef)
\end_layout

\begin_layout Plain Layout

    writeH("hey");
\end_layout

\begin_layout Plain Layout

else
\end_layout

\begin_layout Plain Layout

    writeH("ho"); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Ejecución SME:
\end_layout

\begin_layout Itemize
El proceso inicia como Pᴸ (nivel L).
\end_layout

\begin_layout Itemize
readL() → lee información pública, por lo tanto permanece en L.
\end_layout

\begin_layout Itemize
writeH(...) → esta permitido, ya que un proceso L puede escribir en objetos
 H o L.
\end_layout

\begin_layout Itemize
No hay lectura de datos H, por lo tanto no se crea proceso H.
\end_layout

\begin_layout Itemize
No se produce fork ya que el flujo L → H es seguro y permitido según SME.
 
\end_layout

\begin_layout Subsection*
Programa 2
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "style=cppstyle,caption={Ejemplo: main.cpp}"
inline false
status open

\begin_layout Plain Layout

x = readH();
\end_layout

\begin_layout Plain Layout

writeL("Loading...");
\end_layout

\begin_layout Plain Layout

writeH(x);
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Ejecución SME:
\end_layout

\begin_layout Itemize
Proceso inicia como Pᴸ.
\end_layout

\begin_layout Itemize
Intenta hacer readH().
 El sistema operativo hace un fork:
\end_layout

\begin_deeper
\begin_layout Itemize
Pᴸ: no puede leer x, continúa con una versión sin ese dato.
\end_layout

\begin_layout Itemize
Pᴴ: puede leer x y se reclasifica en nivel H.
\end_layout

\end_deeper
\begin_layout Itemize
writeL("Loading...") es ejecutado solo por Pᴸ (válido).
\end_layout

\begin_layout Itemize
writeH(x) es ejecutado solo por Pᴴ (válido).
\end_layout

\begin_layout Itemize
Cada proceso actúa dentro de sus permisos:
\end_layout

\begin_layout Itemize
Pᴸ no accede a H ni escribe H→L.
\end_layout

\begin_layout Itemize
Pᴴ solo escribe en H.
\end_layout

\begin_layout Itemize
El flujo resulta seguro bajo SME.
 No hay fuga H → L.
\end_layout

\begin_layout Subsection*
Programa 3
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "style=cppstyle,caption={Ejemplo: main.cpp}"
inline false
status open

\begin_layout Plain Layout

x = readH();
\end_layout

\begin_layout Plain Layout

writeL("Loading");
\end_layout

\begin_layout Plain Layout

while (x-- > 100)
\end_layout

\begin_layout Plain Layout

    writeL(".");
\end_layout

\begin_layout Plain Layout

writeH(x); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Ejecución SME:
\end_layout

\begin_layout Itemize
Solo accede a datos de nivel L.
\end_layout

\begin_layout Itemize
Permanece como Pᴸ todo el tiempo.
\end_layout

\begin_layout Itemize
Solo escribe en L, sin interacción con H.
\end_layout

\begin_layout Itemize
No hay fork.
 Totalmente seguro.
  Sin fugas.
\end_layout

\begin_layout Subsection*
Programa 4
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "style=cppstyle,caption={Ejemplo: main.cpp}"
inline false
status open

\begin_layout Plain Layout

user = readL();
\end_layout

\begin_layout Plain Layout

pass = readL();
\end_layout

\begin_layout Plain Layout

if (user == "root" && pass == "1234")
\end_layout

\begin_layout Plain Layout

    msg = "Bienvenido";
\end_layout

\begin_layout Plain Layout

else
\end_layout

\begin_layout Plain Layout

    msg = "Usuario/password incorrecto"; writeL(msg);
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Ejecución SME:
\end_layout

\begin_layout Itemize
Solo accede a datos de nivel L.
\end_layout

\begin_layout Itemize
Permanece como Pᴸ todo el tiempo.
\end_layout

\begin_layout Itemize
Solo escribe en L, sin interacción con H.
\end_layout

\begin_layout Itemize
No hay fork.
 Totalmente seguro.
 Sin fugas.
\end_layout

\begin_layout Subsection*
Programa 5
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "style=cppstyle,caption={Ejemplo: main.cpp}"
inline false
status open

\begin_layout Plain Layout

db_pass = readPassFromDBH();
\end_layout

\begin_layout Plain Layout

db_user = readUserFromDBH();
\end_layout

\begin_layout Plain Layout

user = readL();
\end_layout

\begin_layout Plain Layout

pass = readL();
\end_layout

\begin_layout Plain Layout

if (user == db_user && pass == db_pass)
\end_layout

\begin_layout Plain Layout

    msg = "Bienvenido";
\end_layout

\begin_layout Plain Layout

else
\end_layout

\begin_layout Plain Layout

    msg = "Usuario/password incorrecto";
\end_layout

\begin_layout Plain Layout

writeL(msg);
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Ejecución SME:
\end_layout

\begin_layout Itemize
Proceso inicia como Pᴸ.
\end_layout

\begin_layout Itemize
Al ejecutar readPassFromDBH() o readUserFromDBH() se accede a información
 H.
 Según MSE El sistema operativo hace fork:
\end_layout

\begin_deeper
\begin_layout Itemize
Pᴸ: continúa sin leer los datos H (por ejemplo, variables db_user, db_pass
 quedan vacías o con valores neutros).
\end_layout

\begin_layout Itemize
Pᴴ: lee los verdaderos valores de la base de datos (clasificado en H).
\end_layout

\begin_layout Itemize
Pᴸ: como no tiene los datos H, el if se evalúa como falso → siempre msg
 = "Usuario/password incorrecto".
\end_layout

\begin_layout Itemize
Pᴴ: hace la comparación real, puede escribir en H, pero no puede escribir
 en L.
\end_layout

\end_deeper
\begin_layout Itemize
Resultado visible en L: siempre el mismo mensaje (“incorrecto”).
 Resultado interno en H: completo y verdadero.
\end_layout

\begin_layout Itemize
El flujo resulta seguro bajo SME ya que no hay filtración de información
 H hacia L.
\end_layout

\begin_layout Section*
Ejercicio 23
\end_layout

\begin_layout Standard
En el desafı́o 5 se logra descubrir el valor de h con el siguiente código:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "style=cppstyle"
inline false
status open

\begin_layout Plain Layout

l = true;
\end_layout

\begin_layout Plain Layout

try {
\end_layout

\begin_layout Plain Layout

    if (h) {
\end_layout

\begin_layout Plain Layout

        throw;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    l = false;
\end_layout

\begin_layout Plain Layout

} catch skip;
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Qué tipo de ataque logró llevar adelante?
\end_layout

\begin_layout Standard
Se logró llevar adelante un ataque por canal encubierto o flujo de información
 ilegal, en el cual una variable de bajo nivel (l) obtiene indirectamente
 información sobre una variable de alto nivel (h), violando así la confidenciali
dad del sistema.
\end_layout

\begin_layout Subsection*
Qué limitación tiene el sistema de reglas?
\end_layout

\begin_layout Standard
La limitación del sistema de reglas es que no verifica el nivel de seguridad
 del código que no se ejecuta dentro de un bloque try cuando ocurre un throw
 de alto nivel.
 En consecuencia, permite que partes de código de bajo nivel sean influenciadas
 indirectamente por información de alto nivel.
\end_layout

\begin_layout Subsection*
Qué cambio habría que hacerle para impedir el ataque?
\end_layout

\begin_layout Standard
Para impedir el ataque, el sistema debería imponer una restricción adicional:
 cuando se produzca un throw de alto nivel, se debe garantizar que no se
 ejecuten posteriormente sentencias de nivel inferior.
 Es decir, tras una excepción de alto nivel, el control debe mantenerse
 únicamente dentro de un contexto de igual o mayor nivel de seguridad.
\end_layout

\end_body
\end_document
